# <em>¬µ</em>ce-template

![green field](./test/uce-template-head.jpg)

<sup>**Social Media Photo by [Andrew Seaman](https://unsplash.com/@amseaman) on [Unsplash](https://unsplash.com/)**</sup>

A tiny toolless library with tools included. **[Live demo](https://webreflection.github.io/uce-template/test/)**

- - -

Inspired by [Vue 3 "_One Piece_"](https://github.com/vuejs/vue-next/releases/tag/v3.0.0), _uce-template_ provides a custom builtin `<template>` element to define components in a _Vue_ fashion.

```html
<template is="uce-template">

  <style scoped>
  span { color: green }
  </style>

  <the-green>
    The <span>{{thing}}</span> is green
  </the-green>

  <script type="module">
  export default {
    setup() {
      return {thing: 'world'}
    }
  }
  </script>

</template>
```

Add this library in the equation, and [see it bootstrapping](https://codepen.io/WebReflection/pen/xxVMgZx?editors=1000) all defined components.

- - -

## Getting Started

<details>
  <summary><strong>Features</strong></summary>
  <div>

  * **SSR** compatibility out of the box: components definitions land *once* so no duplicated templates are needed in both layout and *JS*
  * a simple **CLI** that converts any html page or component into its minified version and, optionally, *Babel* transpilation
  * **Custom Elements** based, including builtin extends, so that *IE11*, *Safari*, or any other browser, will work right away
  * optionally **lazy** `<template lazy>` component, to resolve their definition only when live
  * optionally **shadow**ed `<custom-element shadow>` components, and optionally shadowed `<style shadow>` styles
  * a variety of pre-defined modules to import, including a virtual `@uce` module, to create reactive *UIs* and more
  * a runtime *ESM -> CommonJS* **module** system, where relative dependencies are [resolved (once) lazily](./extra-details.md#the-lazy-js-environment), but any imported [module can be pre-defined](./extra-details.md#the-module-js-environment) through the `resolve(name, module)` exported utility
  * everything pre-bundled fits into *10K* gzipped budget, or *9K* via brotli ü¶Ñ

#### Goals

  * demonstrate that tools and tooling can be optional, thanks to the current state of the *Web*
  * avoid any debate regarding duplicated code and re-hydration cost: each component can be served through static pages or dynamic *SSR*, without needing duplicated code around
  * being ahead of time providing the long discussed partial templates already, improving the previous *HTML Imports* idea, which has been dropped anyway, and simplifying scoped styles via auto prefixes or shadow dom
  * being extremely developer friendly with a script anyone can add on any page to start with, with the optional tooling offered by the module itself to optimize stand alone components, or even whole *HTML* pages

  </div>
</details>

<details>
  <summary><strong>CLI</strong></summary>
  <div>

While it's suggested to install the *CLI* globally, due some not-super-light dependency, it's still an `npx` command away:

```sh
# check all options and usage
npx uce-template --help

# works with files
npx uce-template my-component.html

# works with stdin
cat my-component.html | uce-template
```

That's it, but of course we should be sure that produced layout still works as expected üëç

  </div>
</details>

<details>
  <summary><strong>&lt;template&gt;</strong></summary>
  <div>

Any template that extends `uce-template` *must* contain at least a custom element in it, either regular, or built-in extend:

```html
<!-- register regular-element -->
<template is="uce-template">
  <regular-element>
    regular
  </regular-element>
</template>

<!-- register builtin-element as div -->
<template is="uce-template">
  <div is="builtin-element">
    builtin
  </div>
</template>
```

Any template *might* contain a single `<script>` tag, and/or one or more `<style>` definitions.


#### &lt;slot&gt;

If a component contains `{{slot.name}}` definitions, nodes from the living *HTML*, before the component gets upgraded, will be placed in there once live.

See this [live example](https://codepen.io/WebReflection/pen/OJNdZPB?editors=1000) to understand more.

  </div>
</details>

<details>
  <summary><strong>&lt;custom-element&gt;</strong></summary>
  <div>

Each "*component*" might define itself with, or without, its own static, or dynamic, content.

Such *content* will be used to render each custom element once "*mounted*" (live) and per each reactive state change.

All **dynamic parts** must be wrapped within `{{dynamic}}` curly brackets as shown here:

```html
<my-counter>
  <button onclick={{dec}}> - </button>
  <span>{{state.count}}</span>
  <button onclick={{inc}}> + </button>
</my-counter>
```

The `state`, `dec`, and `inc` references will be passed along through the script node, if any.

Regarding **ShadowDOM**, its polyfill is not included in this project but it's possible to define a component through its *shadow root* by adding a *shadow* attribute:

```html
<my-counter shadow>
  <!-- this content will be in the shadowRoot -->
  <button onclick={{dec}}> - </button>
  <span>{{state.count}}</span>
  <button onclick={{inc}}> + </button>
</my-counter>
```

The `shadow` attribute is `open` by default, but it can also be specified as `shadow=closed`.

  </div>
</details>

<details>
  <summary><strong>&lt;style&gt;</strong></summary>
  <div>

A component can have *one or more* styles in it, within a specific *scope*:

  * a generic `<style>` will apply its content globally, useful to address `my-counter + my-counter {...}` cases, as example
  * a `<style scoped>` will apply its content prefixed with the Custom Element name (i.e. `my-counter span, my-counter button {...}`)
  * a `<style shadow>` will apply its content on top of the *shadowRoot*, assuming the component is defined with a `shadow` attribute

There is nothing special to consider here, except that *global* styles might interfere with *IE11* if too obtrusive, as once again *IE11* doesn't understand the `<template>` element purpose and behavior.

  </div>
</details>

<details>
  <summary><strong>&lt;script&gt;</strong></summary>
  <div>

A definition can contain only *one script tag* in it, and such *script* will be virtually handled like a *module*.

Since *IE11* is *not* compatible with `<template>` elements, if the `type` is not specified, *IE11* will try to evaluate all scripts on the page right-away.

Accordingly, the `type` attribute can really have any value, as it's completely irrelevant for this library, but such value must not be IE11 compatible, and `module` is just one value that *IE11* would ignore.

The script *might* contain a `default export`, or even a `module.exports = ...`, where such export *might* have a `setup(element) { ... }` method that returns what the *dynamic* parts of the component expect:

```html
<script type="module">
import {reactive} from '@uce';
export default {
  setup(element) {
    const state = reactive({ count: 0 });
    const inc = () => { state.count++ };
    const dec = () => { state.count-- };
    return {state, inc, dec};
  }
};
</script>
```

The `@uce` *reactive* helper makes it possible to automatically update the view whenever one of its properties changes.

To know more about reactive changes, please [read this Medium post](https://medium.com/@WebReflection/reactive-state-for-data-dom-78332ddafd0e).

  </div>
</details>

- - -

## Examples

This section goal is to showcase basic to complex examples via *uce-template*, where some example might use the `.uce` extension to confine components within their own files.

<details>
  <summary><strong>View <code>.uce</code> files as HTML</strong></summary>
  <div>

If you are using VS Code, you can *Ctrl+Shift+p*, type *settings JSON*, choose *Open Settings (JSON)*, and add the following to such file in order to highlight `.uce` files as *HTML*:

```js
{
  "other-settings": "...",

  "files.associations": {
    "*.uce": "html"
  }
}
```

  </div>
</details>

<details>
  <summary><strong>Lazy Loaded Components</strong></summary>
  <div>

If we define components as `view/my-component.uce` we might as well decide to include these lazily, or better, only when these are found in the current page.

This approach simplifies a lot bundles, dependencies, unnecessary bloat, and it can be done by including just `uce-template` and the tiny <sup><sub>(364 bytes)</sub></sup> [uce-loader](https://github.com/WebReflection/uce-loader#readme) as bootstrap, eventually defining extra dependencies used across components.

```js
import {parse, resolve} from 'uce-loader';
import loader from 'uce-loader';

// optional components dependencies
import something from 'cool';
resolve('cool', something);

// bootstrap the loader
loader({
  on(component) {
    // ignore uce-template itself
    if (component !== 'uce-template')
      fetch(`view/${component}.uce`)
        .then(body => body.text())
        .then(definition => {
          document.body.appendChild(
            parse(definition)
          );
        });
  }
});
```

The same technique could be used directly on any *HTML* page, writing some code that might be compatible with *IE11* too.

```html
<!doctype html>
<html>
  <head>
    <script defer src="//unpkg.com/uce-template"></script>
    <script defer src="//unpkg.com/uce-loader"></script>
    <script defer>
    addEventListener(
      'DOMContentLoaded',
      function () {
        uceLoader({
          Template: customElements.get('uce-template'),
          on: function (name) {
            if (name !== 'uce-template') {
              var xhr = new XMLHttpRequest;
              var Template = this.Template;
              xhr.open('get', name + '.uce', true);
              xhr.send(null);
              xhr.onload = function () {
                document.body.appendChild(
                  Template.from(xhr.responseText)
                );
              };
            }
          }
        });
      },
      {once: true}
    );
    </script>
  </head>
  <body>
    <my-component>
      <p slot="content">
        Some content to show in <code>my-component</code>
      </p>
    </my-component>
  </body>
</html>
```

  </div>
</details>

<details>
  <summary><strong>Lazy Loaded <code>uce-template</code></strong></summary>
  <div>

If the majority of our pages don't use components at all, adding 10K+ of *JS* on top of each page might be undesired.

However, we can follow the very same *Lazy Loaded Components* approach, except our loader will be in charge of bringing in also the *uce-template* library, either when an *uce-template* itself is found, or any other component.

```js
import loader from 'uce-loader';
loader({
  on(component) {
    // first component found, load uce-template
    if (!this.q) {
      this.q = [component];
      const script = document.createElement('script');
      script.src = '//unpkg.com/uce-template';
      document.body.appendChild(script).onload = () => {
        // get the uce-template class to use its .from(...)
        this.Template = customElements.get('uce-template');
        // load all queued components
        for (var q = this.q.splice(0), i = 0; i < q.length; i++)
          this.on(q[i]);
      };
    }
    // when uce-template is loaded
    else if (this.loaded) {
      // ignore loading uce-template itself
      if (component !== 'uce-template') {
        // load the component on demand
        fetch(`view/${component}.uce`)
          .then(body => body.text())
          .then(definition => {
            document.body.appendChild(
              this.Template.from(definition)
            );
          });
      }
    }
    // if uce-template is not loaded yet
    // add the component to the queue
    else
      this.q.push(component);
  }
});
```

Using this technique, our *JS* payload per page would be now reduced to less than *0.5K* once above code gets bundled and minified, while everything else will happen automatically only if there are components somewhere in the page.

  </div>
</details>


<details>
  <summary><strong>CSP integrity</strong></summary>
  <div>

Since `uce-template` inevitably needs to use `Function` to evaluate either [template partials](https://github.com/WebReflection/tag-params#caveats) or in-script *requires*, the latest *integrity* value can be found in here:

```html
<script src="/js/uce-template.js"
        integrity="nXFcDzF++3jp1t0cHwxof4iFavx+BMzwV+rwE7LXwYSQFvI+RmYYzT/vtPI3KUpr"
        crossorigin="anonymous"></script>
```

Please note that this integrity **changes on every release** so please be sure you have the latest version (this README reflects the latest).

  </div>
</details>

- - -

## ... and more!

If you'd like to understand more about `uce-template` and how does it work, please check [this page](./extra-details.mds) out.
